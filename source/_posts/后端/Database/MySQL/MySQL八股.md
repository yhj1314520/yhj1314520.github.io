---
title: MySQL八股
tags:
  - 基础知识
  - Database
  - MySQL
categories:
  - 后端
  - Database
  - MySQL
date: 2023-11-15 15:28:30
---

## ReadMe

## 基础
### 框架
插图
### 怎么使用
#### 命令


### 问题
#### 数据类型选择
1. 设计金钱的选用数据类型，考虑到精度问题选用Decimal和Numric类型表示
	1. Decimal简介——column_name DECIMAL(P,D)，其中P代表有效数字精度1-65默认值为10，D代表小数点后的位数0-30默认值为0. 【D<=P】
	2. Decimal具有UNSIGNED属性【不接受负值】
	3. Deciaml具有ZEROFILL属性【使用0填充不满足列宽的部分】
	4. 对于每个部分使用**4字节** 存储**9位数的每个倍数** 【待调查】
2. 

## 日志
### 三个日志
#### bin log（二进制）
#### redo log（事务）
#### undo log（回滚）
#### 两阶段提交
 原因：bin log & redo log 写入时机不一致，导致在主从恢复时，数据可能不一致。【】
 解决：redo log 的写入分为两步**prepare** & **commit**, 事务执行过程中进行prepare,事务提交过程中commit。当写入bin log异常时，redo log没有进入commit且没有对应的bin log则回滚事务。

 
## 索引（持久性）
### 基础概念
用于快速查询和检索数据的数据结构，常见的实现采用B树、B+树、Hash、红黑树

优点：加快数据检索速度，可以创建唯一性索引保证每一行数据的唯一性
缺点：创建和维护需要消耗时间（对数据增删改）、消耗空间
### 底层实现
#### Hash
#### B树
  二叉树，左节点小于根节点小于叶子节点
#### B+树
  只有**叶子**节点存放key&data（检索效率稳定）
  且叶子节点有引用链指向相邻的叶子节点（范围查询高效）
#### 红黑树
  自平衡二叉树，通过插入（删除）节点时，进行颜色变化和旋转操作，保持平衡

### 分类
#### 根据存储方式
  聚簇索引：索引结构和数据一起存放（**索引-数据**||以数据域的值为地址读取相应的的数据记录，例如主键）
  非聚簇索引：索引结构和数据分开存放（**索引-索引-数据**||叶子节点不一定存放数据的指针）
  覆盖索引：查询的字段正好时索引的字段
  联合索引：使用表种多个字段创建索引（**遵循最左匹配原则**，遇到范围查询停止）
[判断是不是聚簇索引](https://zhuanlan.zhihu.com/p/142139541)(核心在于判断是否要**回表查询**)
#### 根据应用维度
  主键索引：数据表的主键列为索引（不可以有null，表中只有1个）
  唯一索引：加速查询+劣质唯一（可以有null）避免数据重复
  普通索引：仅加速查询，选择数据整齐、紧凑的列
  覆盖索引：一个索引覆盖了**所有**需要查询的字段值
  联合索引：多列值组成一个索引，专门用于搜索，效率大于索引合并？
  全文索引：目前只有CHAR\VARCHAR\TEXT列上可以创建全文索引，一般采用ElasticSearch代替
### 使用
#### 索引优化（建立）
  1. 创建单列还是多列索引--->如果拆线呢语句中的where、order by、group涉及多个字段，一般需要创建多列索引，例如：
```sql
select * from user where name="h" and job="programmer";
```
  2. 多列索引的顺序选择---->将选择性高的字段【能定位的数据更少】放在前面，**但是**，满足某个查询场景就可能导致另外一个查询场景慢。
```sql
select * from user where age='20' and name='zh' order by name;
```
  3. 避免使用范围查询---->很多情况下，范围查询都可能导致无法使用索引
  4. 尽量避免查询不需要的数据---->减少【\*】的使用
```sql
explain select * from user where job like '%grammer'; # 全表遍历
explain select job from user where job like '%grammer'; # 使用覆盖索引
```
  5. 查询的数据类型要正确
```sql
explain select * from user where create_Date >= now(); # 可以使用create_date的索引
explain select * from user where create_Date >="2023-11-23"; # 不可以
```
#### 索引命中（失效）
  1. 对索引列进行操作（加减操作）
  2. 使用or + 没有索引的列
  3. 存在隐式类型转换，例如字符串查询，输入数字会转为浮点（）
  4. like通配符，以【%】开头进行的模糊查询（建议使用覆盖索引或以将%放后面）
  5. !=, not in, is null, not null
  6. 查询联合索引不满足最左原则
  
#### 最左匹配
##### 定义
  针对**联合索引**，根据索引进行优化，将确定值的索引列排在前面，按索引顺序进行查询（避免范围查询引起后面索引的无序）  [看不懂请看原篇](https://cloud.tencent.com/developer/article/1774781)
  举例
  ```sql
  # 某表现有索引（a,b,c）
  select * from t where a=1 and b=1 and c=1;#利用索引a,b,c
  select * from t where a=1 and b=1; # 只能用到索引中的a,b
  select * from t where b=1 and a=1; # 只能用到索引中的a,b(mysql查询优化器)
  select * from t where a=1;         # 只能用到索引中的a
  select * from t where b=1 and c=1; # 不能使用索引
  select * from t where a=1 and c=1; # 只能用到索引中的a
```
##### 原理
  因为索引**底层实现是B+树**
  插图
##### 为啥使用联合索引
 1. 减少开销。建立一个联合索引(col1, col2, col3)，实际相当于建立(col1), (col1, col2), (col1, col2, col3)三个索引。每多一个索引会增加写操作的时空开销。
 2. 覆盖索引。对于联合索引(col1, col2, col3)，采用`select col1....`sql语句会之间通过遍历索引获取数据，无需**回表**，减少IO操作。
 3. 效率高。索引列越多，筛选的数据越少


#### 索引下推
##### 定义
 在非聚簇索引遍历过程中，对索引中包含的字段先左判断，过滤掉不符合条件的记录，减少回表次数（核心在于判断条件中某一部分不在应用程序而是交给数据引擎）
##### 逻辑
 1. 存储引擎读取索引记录（不是完整的行记录）
 2. 判断WHERE条件**部分**能否用**索引中的列**来检查，条件不满足则处理下一行
 3. 条件满足，使用索引中的主键定位并读取完成的行记录（回表）
 4. 存储引擎将记录交给Server层，Server层检测记录是否满足WHERE条件其余部分。
##### 使用条件
  - 对于InnoDB只适用于二级（辅助）索引
  - 引用了**子查询**的条件以及**存储函数**的条件不能下推
#### 慢查询
##### 定义
##### 使用
  - 通过skywalking压测时查询到某一具体接口
  - MySQL开启慢日志查询
  - SQL优化---通过EXPLAIN 命令查看是否使用索引
#### 回表查询
 |动作|使用聚簇索引|使用非聚簇索引|
 |:----:|:-----:|:------:|
 |列经常被分组排序|应|应|
 |返回某范围内的数据|应|不应
 |一个或极少不同值|不应|不应
 |小数目的不同值|应|不应|
 |大数目的不同值|不应|应
 |频繁更新的列|不应|应|
 |外键列|应|应
 |主键列|应|应
 |频繁修改索引列|不应|应|
 
 ##### 查询过程
 **todo**
 ##### 误区
 **聚簇索引默认是主键**，如果表中没有定义主键，InnoDB会选择**唯一的非空索引**代替，
									 如果没有唯一非空索引，InnoDB会**隐式定义一个主键**。
 ##### 优缺点
  每次使用辅助（非聚簇）索引检索都要经过两次B+树查找
  优点：
	  1. 行数据和叶子节点存储在一起，同一页中会有多行数据，页是加载到内存中，再次访问会从内存中读取。
	  2. 非聚簇索引，使用主键作为”指针“，减少当出现行移动或数据页分裂【行的位置随数据修改而变化】需要的维护。即InnoDB在移动行时，无序更新辅助索引的指针。
	  3. 聚簇索引适合排序场合或进行范围查询
  缺点：
	  1. 维护聚簇索引很麻烦，数据移动会造成空间碎片
	  2. 如果主键存储稀疏（？），可能出现聚簇索引比全表扫描慢
 
 







## 事务（隔离性）
### 事务隔离级别
#### 四种隔离级别
#### MVCC


### 事务实现


## 锁（原子性）
### 锁分类
### 使用
#### update加锁
#### select 加锁
