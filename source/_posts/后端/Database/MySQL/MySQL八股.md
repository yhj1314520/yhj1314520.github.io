---
title: MySQL八股
tags:
  - 基础知识
  - Database
  - MySQL
categories:
  - 后端
  - Database
  - MySQL
date: 2023-11-15 15:28:30
---

## ReadMe

## 基础
### 框架
插图
### 怎么使用
#### 命令


### 问题
#### 数据类型选择
1. 设计金钱的选用数据类型，考虑到精度问题选用Decimal和Numric类型表示
	1. Decimal简介——column_name DECIMAL(P,D)，其中P代表有效数字精度1-65默认值为10，D代表小数点后的位数0-30默认值为0. 【D<=P】
	2. Decimal具有UNSIGNED属性【不接受负值】
	3. Deciaml具有ZEROFILL属性【使用0填充不满足列宽的部分】
	4. 对于每个部分使用**4字节** 存储**9位数的每个倍数** 【待调查】
#### 自增主键ID
使用自增id,尽量避免不断的调整数据的物理地址，保证数据存放物理地址的相邻紧凑。但**不一定连续**，比如【**初始值和自增步长设置不为1**】【**唯一键冲突**】【**事务回滚**】【**批量插入**】
1.  auto_increment_offset(自增初始值)，auto_increment_increment（自增步长） 设置的初始值以及步长都不一定为1。
2. 唯一键冲突——在进行插入的过程中，会先进行自增id的自增操作，然后进行插入操作。
3. 事务回滚——对两个并行执行的事务A&B，为避免得到相同的自增id，需要加锁顺序申请。
	1.  假设事务A申请得到id = 1，事务B得到id = 2。表的自增id = 3
	2. 假设事务B正确提交，但是事务A出现了唯一键冲突，即id=1的记录失败。如果允许事务A将自增id回退，表的自增id 将被改回为1.那么现在表的情况就是，表的自增id为1，但是存在自增id = 2的记录
	3.  执行的其他事务得到自增id=2, 就会出现主键冲突的错误
4. MySQL批量申请自增id——同一个语句【例如insert,】申请自增id，都会是上一次的两倍（id个数没用完就会废弃掉）
## 日志（一致性）
### 三个日志
#### bin log（二进制）
 逻辑日志，记录语句的原始逻辑（记录涉及更新数据的逻辑操作，顺序写）
 日志格式：
                 statement---记录SQL语句，但记录的时间和事务时间不一致
				 row-----需要mysql bin log 解析，存储占用空格键大
				 mixid----前两者的混合，如果引起数据不一致，采用row格式
 写入机制：
				 事务执行过程中，日志写到**binlog cache**中，事务提交时，将缓存写到bin log文件
				 **事务提交时写入**
#### redo log（事务）
  buffer pool(从硬盘按**页**加载的数据存放，类似缓存)-----对应redo log buffer
  刷盘（写入）：
					  每次事务提交时不进行刷盘操作，由后台线程1秒刷盘一次（事务执行时）
					  每次事务提交时都进行刷盘操作（默认值）
					  每次事务提交时，只把redo log buffer内容写入到page cache
#### undo log（回滚）
 记录事务进行的修改，先于事务执行。先于数据持久化到磁盘。
  insert产生的undo log在回滚时需要，事务提交后可被立即删除。
  update\delete 产生的undo log 在回滚时需要，MVCC也需要。
  **undo log版本链**记录之前的旧数据。

#### 两阶段提交
  原因：bin log & redo log 写入时机不一致，导致在主从恢复时，数据可能不一致。【】
  解决：redo log 的写入分为两步**prepare** & **commit**, 事务执行过程中进行prepare,事务提交过程中commit。当写入bin log异常时，redo log没有进入commit且没有对应的bin log则回滚事务。

 
## 索引（持久性）
### 基础概念
用于快速查询和检索数据的数据结构，常见的实现采用B树、B+树、Hash、红黑树

优点：加快数据检索速度，可以创建唯一性索引保证每一行数据的唯一性
缺点：创建和维护需要消耗时间（对数据增删改）、消耗空间
### 底层实现
#### Hash
#### B树
  二叉树，左节点小于根节点小于叶子节点
#### B+树
  只有**叶子**节点存放key&data（检索效率稳定）
  且叶子节点有引用链指向相邻的叶子节点（范围查询高效）
#### 红黑树
  自平衡二叉树，通过插入（删除）节点时，进行颜色变化和旋转操作，保持平衡

### 分类
#### 根据存储方式
  聚簇索引：索引结构和数据一起存放（**索引-数据**||以数据域的值为地址读取相应的的数据记录，例如主键）
  非聚簇索引：索引结构和数据分开存放（**索引-索引-数据**||叶子节点不一定存放数据的指针）
  覆盖索引：查询的字段正好时索引的字段
  联合索引：使用表种多个字段创建索引（**遵循最左匹配原则**，遇到范围查询停止）
[判断是不是聚簇索引](https://zhuanlan.zhihu.com/p/142139541)(核心在于判断是否要**回表查询**)
#### 根据应用维度
  主键索引：数据表的主键列为索引（不可以有null，表中只有1个）
  唯一索引：加速查询+劣质唯一（可以有null）避免数据重复
  普通索引：仅加速查询，选择数据整齐、紧凑的列
  覆盖索引：一个索引覆盖了**所有**需要查询的字段值
  联合索引：多列值组成一个索引，专门用于搜索，效率大于索引合并？
  全文索引：目前只有CHAR\VARCHAR\TEXT列上可以创建全文索引，一般采用ElasticSearch代替
### 使用
#### 索引优化（建立）
  1. 创建单列还是多列索引--->如果拆线呢语句中的where、order by、group涉及多个字段，一般需要创建多列索引，例如：
```sql
select * from user where name="h" and job="programmer";
```
  2. 多列索引的顺序选择---->将选择性高的字段【能定位的数据更少】放在前面，**但是**，满足某个查询场景就可能导致另外一个查询场景慢。
```sql
select * from user where age='20' and name='zh' order by name;
```
  3. 避免使用范围查询---->很多情况下，范围查询都可能导致无法使用索引
  4. 尽量避免查询不需要的数据---->减少【\*】的使用
```sql
explain select * from user where job like '%grammer'; # 全表遍历
explain select job from user where job like '%grammer'; # 使用覆盖索引
```
  5. 查询的数据类型要正确
```sql
explain select * from user where create_Date >= now(); # 可以使用create_date的索引
explain select * from user where create_Date >="2023-11-23"; # 不可以
```
#### 索引命中（失效）
  1. 对索引列进行操作（加减操作）
  2. 使用or + 没有索引的列
  3. 存在隐式类型转换，例如字符串查询，输入数字会转为浮点（）
  4. like通配符，以【%】开头进行的模糊查询（建议使用覆盖索引或以将%放后面）
  5. !=, not in, is null, not null
  6. 查询联合索引不满足最左原则
  
#### 最左匹配
##### 定义
  针对**联合索引**，根据索引进行优化，将确定值的索引列排在前面，按索引顺序进行查询（避免范围查询引起后面索引的无序）  [看不懂请看原篇](https://cloud.tencent.com/developer/article/1774781)
  举例
  ```sql
  # 某表现有索引（a,b,c）
  select * from t where a=1 and b=1 and c=1;#利用索引a,b,c
  select * from t where a=1 and b=1; # 只能用到索引中的a,b
  select * from t where b=1 and a=1; # 只能用到索引中的a,b(mysql查询优化器)
  select * from t where a=1;         # 只能用到索引中的a
  select * from t where b=1 and c=1; # 不能使用索引
  select * from t where a=1 and c=1; # 只能用到索引中的a
```
##### 原理
  因为索引**底层实现是B+树**
  插图
##### 为啥使用联合索引
 1. 减少开销。建立一个联合索引(col1, col2, col3)，实际相当于建立(col1), (col1, col2), (col1, col2, col3)三个索引。每多一个索引会增加写操作的时空开销。
 2. 覆盖索引。对于联合索引(col1, col2, col3)，采用`select col1....`sql语句会之间通过遍历索引获取数据，无需**回表**，减少IO操作。
 3. 效率高。索引列越多，筛选的数据越少


#### 索引下推
##### 定义
 在非聚簇索引遍历过程中，对索引中包含的字段先左判断，过滤掉不符合条件的记录，减少回表次数（核心在于判断条件中某一部分不在应用程序而是交给数据引擎）
##### 逻辑
 1. 存储引擎读取索引记录（不是完整的行记录）
 2. 判断WHERE条件**部分**能否用**索引中的列**来检查，条件不满足则处理下一行
 3. 条件满足，使用索引中的主键定位并读取完成的行记录（回表）
 4. 存储引擎将记录交给Server层，Server层检测记录是否满足WHERE条件其余部分。
##### 使用条件
  - 对于InnoDB只适用于二级（辅助）索引
  - 引用了**子查询**的条件以及**存储函数**的条件不能下推
#### 慢查询
##### 定义
##### 使用
  - 通过skywalking压测时查询到某一具体接口
  - MySQL开启慢日志查询
  - SQL优化---通过EXPLAIN 命令查看是否使用索引
#### 回表查询
 |动作|使用聚簇索引|使用非聚簇索引|
 |:----:|:-----:|:------:|
 |列经常被分组排序|应|应|
 |返回某范围内的数据|应|不应
 |一个或极少不同值|不应|不应
 |小数目的不同值|应|不应|
 |大数目的不同值|不应|应
 |频繁更新的列|不应|应|
 |外键列|应|应
 |主键列|应|应
 |频繁修改索引列|不应|应|
 
 ##### 查询过程
 **todo**
 ##### 误区
 **聚簇索引默认是主键**，如果表中没有定义主键，InnoDB会选择**唯一的非空索引**代替，
									 如果没有唯一非空索引，InnoDB会**隐式定义一个主键**。
 ##### 优缺点
  每次使用辅助（非聚簇）索引检索都要经过两次B+树查找
  优点：
	  1. 行数据和叶子节点存储在一起，同一页中会有多行数据，页是加载到内存中，再次访问会从内存中读取。
	  2. 非聚簇索引，使用主键作为”指针“，减少当出现行移动或数据页分裂【行的位置随数据修改而变化】需要的维护。即InnoDB在移动行时，无序更新辅助索引的指针。
	  3. 聚簇索引适合排序场合或进行范围查询
  缺点：
	  1. 维护聚簇索引很麻烦，数据移动会造成空间碎片
	  2. 如果主键存储稀疏（？），可能出现聚簇索引比全表扫描慢
 
 
## 锁（原子性）
在delete和update操作时，可以直接对记录加锁（Record Lock只能锁住已存在的记录），但是insert操作，则需要间隙锁（Gap Lock）。
### 锁分类
#### 根据锁粒度
表级锁：针对**非索引字段**加的锁，对当前操作的整张表加锁，实现简单，资源消耗少，但锁冲突高，高并发效率低。
行级锁：针对**索引字段**加的锁，只针对当前操作的行记录进行加锁。但开销大，会出现死锁。（*如果【where】条件中字段没有命中唯一索引或索引失效，会导致对全表的所有行记录加锁*）
InnoDB的行锁：**记录锁**——所以单个行记录。**间隙锁**——锁定一个范围，不包含记录本身。**Next-Key Lock**——前两者结合，锁定一个范围，包含记录本身，目的是为了解决幻读问题
#### 根据锁目的
##### 读写锁
共享锁(S锁)：读锁，事务在读取记录时获取S锁，允许多个事务同时获取
排他锁(X锁)：写锁/独占锁，事务在修改记录时候获取X锁，不允许多个事务同时获取。一个记录被加了X锁，其他事务不能对该记录加**任何锁**（读读并行可以，但写读，写写并行不）
##### 意向锁
可以快速判断表中的记录有没有行锁。意向锁之间互相兼容。与表级的X锁互斥。
意向共享锁（IS）：事务有意向对表中的某些记录加共享锁S锁，加S锁前必须获取该表的IS锁。
意向排他锁（IX）：事务有意向对表中的某些记录加排他锁X锁，加X锁前必须获得该表的IX锁。

### 使用
1.  select....for update 对读取的记录加独占锁
2.  select....lock in share mode 对读取的记录加共享锁
3.  使用delete 自动加独占锁
4.  使用update 自动加独占锁
【在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁避免幻读】
- 只使用唯一索引查询时，且只锁定一条记录，innoDB使用行锁-recordLock
- 只是用唯一索引拆线呢时，但是检索条件是范围检索，或者唯一检索但检索结果不存在时，会产生Next-Key Lock
- 使用普通索引检索时，不管时何种查询只要加锁都会产生间隙锁（GapLock）
- 同时使用唯一索引和普通索引时，由于数据行是优先根据普通索引排序，再根据唯一索引排序，所以也会产生间隙锁（Gap Lock）
#### update加锁
[看不懂请看原篇](https://www.maoyingdong.com/mysql-update-sql-locking/)
##### 产生哪些锁：
MDL读锁——Metadata locking元数据锁，用于保护表结果、触发器等并发访问的一致性，阻塞表结构修改语句（添加、删除字段）
意向写锁——表级锁，只会阻塞LOCK TABLES xxx WRITE语句
行级锁——包括记录锁RecordLock, 间隙锁Gap Lock 以及Next-key Lock(前两者组合)。

1.  通过主键更新1条记录【update t1 set age =222 where id = 5;】
	1. id=5的记录存在，只会再该主键索引上加一个记录锁；
	2. id=5的记录不存在，主键索引加上一个间隙锁，阻止其他事务往该间隙插入数据。
2. 通过主键更新一个范围【update ...... where id >= 5】

	1. 给id=5加上记录锁
	2. 给id=6加上记录锁
	3. 给（6，无穷）加上间隙锁，插入id=8的记录会被间隙锁阻塞
 3. 通过无索引的字段更新【update  t1 set age =100 where age=200】
	1. age上的字段没有索引，则update语句会锁住表格中每一条记录和每个间隙，其他update insert delete语句无法执行

4.  通过唯一索引更新，where使用唯一索引更新记录【update....where d = 80】
	1. 当d=80记录存在.
		1. 给唯一索引d=80记录加上行锁（没有间隙锁）
		2. d=80对记录的主键索引也会加上行锁（没有间隙锁）
	2.  没有用到的辅助索引c不受影响
	3. 当d=80记录不存在，则添加间隙锁

5.  唯一索引范围更新【update... where d > 70】
	1. 给匹配到的主键索引记录加上行锁
	2. 给匹配到的唯一辅助索引记录加上行锁
	3. 给辅助索引加上间隙锁
 
6. 通过非唯一（二级）索引更新【updat..... where c =300】
	1. 在辅助索引上加上Next-key锁
	2. 给where条件匹配到的记录加上行锁

7. 多个条件更新
	1. 看使用了那个索引，再根据索引判断加锁
#### select 加锁


## 事务（隔离性）
### 事务隔离级别
#### 四种隔离级别
|事务隔离级别|解释|脏读|不可重复读|幻读|
|:---:|:---:|:--:|:--:|:---:|
|READ-UNCOMMITED|允许读取未提交的数据|&#10004|&#10004|&#10004|
|READ-COMMITED|读取并发事务提交的数据||&#10004|&#10004|
|REAPEATABLE-READ|对同一字段的多次读取结果相同|||&#10004|
|SERIALIZABLE|所有事务依次逐个执行|||||
 InnoDB默认采用的是RR隔离级别，因此存在幻读的问题，解决方法则是使用MVCC以及Next-keyLock(记录锁和间隙锁结合)
 **脏读**——事务A读取事务B未提交的数据，事务B回滚导致事务A读取的数据错误。
 **不可重复读**——事务A执行读取过程中，事务B更改其中读取的数据，使得事务A前后读取的**树不一致**
 **幻读**——事务A读取过程中，事务B对其进行**增删操作**，使得事务A读取的**数据量不一致**。
#### 快照读
定义：一致性非锁定读，就是单纯的SELECT(不包括【FOR UPDATE】&【LOCK IN SHARE MODE】)。读取的记录正在执行UPDATE/DELETE操作，读取不会等记录上的X锁释放，而是读取历史版本（快照）。

场景：只有在RC(读取已提交)&RR(可重读),使用快照读。RC下读取最新的快照，RR下读取本事务开始时的快照。因此，适用于对于数据一致性要求不是特别高且追求极致性能的场景
#### 当前读
定义：一致性锁定读，给行记录加X锁或S锁。(INSERT/UPDATE/DELETE）也叫锁定读

举例：SELECT...LOCK IN SHARE MODE:对记录加S锁，其他事务也可以加S锁，加X锁则会阻塞。
UPDATE/INSERT/DELETE:对记录加X锁，其他事务不能加任何锁
#### MVCC
多版本并发控制（multi-version concurrency control）具体实现则是依赖**隐藏字段**，**read view**以及**undo log**。

##### 使用
通过数据行的隐藏字段【DB_RTX_ID】+Read View判断数据的可见性。不可见，则通过【DB_ROLL_PTR】+undo log找到历史版本。所以，同一个事务只能看到该事务创建Read view之前已经提交的修改和该事务本身做的修改。
MVCC下，当一个事务要对数据库中的数据进行修改，MVCC为该事务创建一个数据快照，而不是直接修改数据行。

读操作下：使用快照读，选择符合事务开始时间的数据版本，有多版本时，选择最新

写操作下：为修改的数据行创建一个新的版本，带有当前事务的版本号

版本回收：MVCC定期进行版本回收，释放空间（底层？）
**解决不可重复读**
- RC隔离级别，每次select查询前都生成一个Read View,会导致不可重复
- RR隔离界别，事务开始后第一次select数据前生成Read view，在RR级别下实现可重复读。
**解决幻读**
- 普通的select语句，会使用快照读：在RR隔离级别只会在事务开启后的第一次查询生成Read View，使之后其他事务所做的插入、更新等对当前事务并不可见。
- 使用当前读：InnoDB使用Next-key Lock，锁定读取的记录，并锁定它们的间隙，防止其他事务在查询范围内插入数据。
  
##### 隐藏字段
  InnoDB为每行数据添加了三个隐藏字段：
  DB_TRX_ID(6byte)：标识最后一次插入或更新该行的事务ID，此外`DELETE`操作在内部被视为更新，只不过会在记录头Recordheader中的delete_flage字段标记为已删除。
  DB_ROLL_PTR(7byte)：回滚指针，指向改行的undo_log，如果该行未被更新则为空。
  DB_ROW_ID(6byte)：如果没有设置主键且该表没有唯一非空索引时，InnoDB会使用该ID来生成聚簇索引。
##### Read view
`trx_id_t m_low_limit_id` ----目前出现过的最大的事务ID + 1为下一个将被分配的事务ID。大于等于这个ID的数据版本均不可见
`trx_id_t m_up_limit_id`------活跃事务列表m_ids中最小的事务ID，如果m_ids为空，则等上一个m_low_limit_id。小于这个ID的数据版本可见
`trx_id_t m_creator_trx_id`---创建该Read view的事务ID
`trx_id_t m_low_limit_no` ----事务number,小于number的undo logs均可以被Purge.
`ids_t m_ids`-------------------Read view创建时其他未提交的活跃事务ID列表。创建Read View时，将当前未提交事务ID记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。    不包括当前事务自己和已提交的事务（正在内存中）
`m_closed`----------------------标记Read view是否关闭
##### undo log
- MVCC中，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过undo log读取之前的版本数据，依次实现非锁定读
- insert undo log——在insert操作产生的undo log.因为insert操作的记录只对事务本身可见，对其他事务不可见.故该undo log可以在事务提交后直接删除，不需要进行purge操作
- update undo log——在update/delete操作中产生的undo log。可能需要提供MVCC机制，因此不能在事务提交时进行删除，而是放入undo log 链表（链尾是最早的旧纪录，链首是最新的记录），等待purge线程进行最后的删除

### 事务实现



