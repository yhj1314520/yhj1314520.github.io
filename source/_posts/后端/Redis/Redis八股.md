---
title: Redis八股
tags:
  - Redis
  - 基础知识
categories:
  - 后端
  - Redis
date: 2023-11-15 15:03:19
---
## ReadMe
## 基础知识
### 数据类型
### 数据结构

### 持久化
#### AOF(AppendOnlyFile)

#### RDB(redisDatabase)
### 网络模型


## 缓存

### 三问
#### 缓存雪崩
#### 缓存穿透
#### 缓存击穿

#### 缓存&DB一致性

## 消息队列

### List实现
### Pub/Sub实现
### ZSet实现
### Stream实现
### 问题

### 对比Kafka

### 对比RabbitMQ




## 分布式锁

### 实现原理
 CAP理论，即C(consistency)一致性、A(Availabilty)可用性、P(Partition tolerance)分区容错性
 P是必要因素，所以分为AP&CP两种，核心在于一致性是否牺牲

### Rediss 实现-AP
#### 目的
AP模式下的分布式锁，目的在于保证系统的**可用性**，要求数据一致性不严苛。
1. SETNEX: key不存在的情况下，设置value，否则不做操作。设置成功返回为1，失败为0
2. EXPIRE: 设置过期时间（避免死锁）
3. lua脚本确保上锁的原子操作（避免死锁）
4. 释放锁通过删除del实现
	1. value字段添加当前线程id(锁标识)，避免误删
5. 可重入（记录加锁次数以及锁标识，Map结构）
6. 自动续期（避免业务时间过长或锁持有时间太短）
#### 实现
##### Jedis

##### Redission


#### 问题
Redis存储结构无法保证主从节点数据的一致性，无法保证主节点宕机时，所有数据自动同步到从节点。Redis分布式锁会在主节点宕机情况下，**丢失锁信息**，出现重复上锁
### zookeeper实现-CP

#### 目的

zookeeper有一种节点类型为临时序号节点，按序号自增创建临时节点。
其创建可以分为读锁和写锁
读锁获取：
	1、根据资源ID创建临时序号节点：/lock/mylcokR0005 Read
	2、获取/lock下所有子节点，判断比它小的节点是否**全是**读锁，如果是则获取成功
	3、如果不是（表明有写锁），阻塞等待，监听自己前一个节点
	4、当前面一个节点**发生变更**(删除)，重新执行第二步
写锁获取：
	1、根据资源ID创建临时序号节点：/lock/mylcokR0006 Write
	2、获取/lock下所有子节点，**判断最小的节点是否是自己**，如果是则上锁
	3、如果不是，则阻塞等待，监听前一个节点
	4、当前一个节点发生变更(删除)，重新执行第二步
#### 实现

#### 问题

[1]https://blog.csdn.net/qq_41401800/article/details/106764515
[2]https://blog.csdn.net/qq_41973594/article/details/113576268





## 主从同步

### 哨兵

### 集群



