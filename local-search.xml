<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DockerFile</title>
    <link href="/2023/11/b864d8044ae9.html"/>
    <url>/2023/11/b864d8044ae9.html</url>
    
    <content type="html"><![CDATA[<h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Dockerfile是一个用来构建镜像的文本文件，文本内容包含一条条构建镜像所需的指令和说明。其目的是为了构建镜像，不同环境下可以复现相同的容器。<br>每个指令都会在镜像的构建过程中创建一个<strong>新的镜像层</strong> </p><h2 id="包含指令"><a href="#包含指令" class="headerlink" title="包含指令"></a>包含指令</h2><p>感谢[<a href="https://cloud.tencent.com/developer/article/2327632]">https://cloud.tencent.com/developer/article/2327632]</a></p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><strong>第一个指令，必须的指令</strong> 用于指定构建新镜像时所基于的基础镜像，可以是官方的也可以是他人的</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">格式：<br><span class="hljs-keyword">FROM</span> &lt;image&gt;<br><span class="hljs-keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;<br>示例：<br><span class="hljs-keyword">FROM</span> nginx:<span class="hljs-number">1.25</span>.<span class="hljs-number">1</span>-alpine<br></code></pre></td></tr></table></figure><h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>用于指定镜像的维护者信息，和LABEL指令类似，添加作者、维护者等元数据</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">格式：<br><span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br>示例：<br><span class="hljs-keyword">MAINTAINER</span> Henry Fish<br><span class="hljs-keyword">MAINTAINER</span> XXX@qq.com<br></code></pre></td></tr></table></figure><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>用于向镜像添加元数据标签，可选指令，为镜像添加描述信息，类似README? <strong>建议尽量选择LABEL指令</strong> ,因为MAINTAINER指令仅局限于指定维护者</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">格式：<br><span class="hljs-keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span><br>示例：<br><span class="hljs-keyword">LABEL</span><span class="language-bash"> <span class="hljs-string">&quot;com.example.vendor&quot;</span>=<span class="hljs-string">&quot;ACME Incorporated&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> com.example.label-with-value=<span class="hljs-string">&quot;foo&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0&quot;</span></span><br></code></pre></td></tr></table></figure><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>用于再镜像中执行命令，以便再构建过程中安装包配置环境等。<br>RUN指令执行的<strong>命令</strong>会在新的镜像层中运行，利用D<strong>ocker的缓存机制</strong>在后续构建中，只有该层之前的内容发生变化时才重新运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">默认<span class="hljs-keyword">Shell</span><span class="language-bash">格式：</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y python3</span><br>Exec格式：（避免<span class="hljs-keyword">Shell</span><span class="language-bash">中发生意外的解释问题）</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;apt-get&quot;</span>,<span class="hljs-string">&quot;update&quot;</span>]</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> [<span class="hljs-string">&quot;apt-get&quot;</span>,<span class="hljs-string">&quot;install&quot;</span>,<span class="hljs-string">&quot;-y&quot;</span>,<span class="hljs-string">&quot;python3&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>因为每个RUN指令都会创建一个新的镜像层，为减少镜像层数，使用&amp;&amp; 连接多个命令</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>用于定义容器启动时<strong>默认要执行的命令</strong>。一个Dockerfile中<strong>只能包含一个CMD</strong>指令，多个则只有最后一个生效。<br>使用<code>docker run</code>命令启动容器时，没有其他指定的命令，会执行CMD中定义的命令，有则会覆盖CMD定义的默认启动命令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">Shell</span><span class="language-bash">格式：在Shell中执行</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> python app.py</span><br>Exec格式：在容器中直接执行<br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>,<span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>用于配置容器启动时的默认执行命令，类似于CMD指令,一样有shell格式和exec数组格式</p><ul><li>ENTRYPOINT指令的命令会在容器启动时始终执行，无论<code>docker run</code>是否指定其他命令，不会被<strong>覆盖</strong>，而是作为容器的主要执行命令</li><li>如果在<code>docker run</code>命令指定了其他命令，这些命令将作为ENTRYPOINT指令的参数进行传递<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;echo&quot;</span>,<span class="hljs-string">&quot;Hello&quot;</span>]</span><br></code></pre></td></tr></table></figure>无其他参数<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ docker build -t mu_image .<br>$ docker <span class="hljs-keyword">run</span><span class="language-bash"> my_image</span><br>Hello<br></code></pre></td></tr></table></figure>提供其他参数<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-built_in">run</span> my_image <span class="hljs-string">&quot;World&quot;</span><br>Hello World<br></code></pre></td></tr></table></figure>可以使用ENTRYPOINT指令定义一个可执行的程序或脚本，容器启动时运行该程序，将Docker容器作为可执行应用来使用</li></ul><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>用于声明容器在运行时监听的网络端口，<strong>不会实际打开或映射端口</strong>，而是作为一个文档功能，用于告知程序将使用指定的端口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><span class="hljs-comment"># 声明容器将监听80端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>在使用docker run命令启动容器时，如果需要通过主机访问容器的80端口，需要使用**-p选项进行端口映射**</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$ docker run -p <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> my_image<br>//这样可以通过主机的<span class="hljs-number">8080</span>端口访问容器的服务<br></code></pre></td></tr></table></figure><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>用于将文件、目录或远程URL复制到镜像中，支持<strong>自动解压缩</strong>，将压缩文件解压至指定目录下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">格式：<br><span class="hljs-keyword">ADD</span><span class="language-bash"> SOURCE DESTINATION</span><br>示例：<br><span class="hljs-keyword">ADD</span><span class="language-bash"> https://...... /tmp/</span><br></code></pre></td></tr></table></figure><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>相比于ADD指令，缺少自动解压功能。在复制文件的场景下，推荐使用COPY，避免引起不必要的意外行为。</p><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>设置环境变量的指令，环境变量在容器运行时可用</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">格式：<br><span class="hljs-keyword">ENV</span> KEY VALUE<br>示例：<br><span class="hljs-keyword">ENV</span> MY_NAME  HENRY<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$MY_NAME</span></span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$MY_NAME</span>&quot;</span></span><br></code></pre></td></tr></table></figure><p>同时可以通过docker run命令的-e选项覆盖环境变量值</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ docker <span class="hljs-built_in">run</span> -e <span class="hljs-attribute">MY_NAME</span>=<span class="hljs-string">&quot;ALICE&quot;</span> my_image<br></code></pre></td></tr></table></figure><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>设置工作目录(当前目录)，容器启动时，进程的当前工作目录将被设置为WORKDIR指令指定的目录</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /APP</span><br></code></pre></td></tr></table></figure><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><h4 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h4><h4 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h4><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用官方的python 3基础镜像</span><br><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3</span><br><span class="hljs-comment"># 将当前目录下的文件复制到镜像中的 /APP目录中</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /APP</span><br><span class="hljs-comment">#设置工作目录为</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /APP</span><br><span class="hljs-comment">#安装依赖包（自定义的requirements.txt）</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><br><span class="hljs-comment">#暴露容器监听端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><span class="hljs-comment">#定义容器启动时运行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;app.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h4><p>在一个Dockerfile中使用多个FROM指令，每个FROM指令代表一个构建阶段。每个构建阶段，可以从之前的阶段复制所需的文件，并执行特定的构建操作。<strong>多阶段构建使得最终生成的镜像只包含运行应用程序所必须的依赖和文件</strong>，不包含构建过程中产生的不必要文件和依赖<br>eg:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 构建阶段1</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.17</span> as builder<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -o myapp <span class="hljs-comment"># 编译应用程序</span></span><br><span class="hljs-comment"># 构建阶段2</span><br><span class="hljs-keyword">FROM</span> alpine:latest<br><span class="hljs-comment"># 复制编译后的应用程序</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/myapp /usr/local/bin/</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/local/bin</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure><h4 id="多层构建优化"><a href="#多层构建优化" class="headerlink" title="多层构建优化"></a>多层构建优化</h4><p>在一个Dockerfile中使用多个RUN指令来构建镜像，通过&amp;&amp;操作符将多个命令合并成一个，减少Docker镜像的大小</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]<a href="https://cloud.tecent.com/developer/article/2327632">https://cloud.tecent.com/developer/article/2327632</a><br>[2]</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring数据源配置</title>
    <link href="/2023/11/29245e69ac50.html"/>
    <url>/2023/11/29245e69ac50.html</url>
    
    <content type="html"><![CDATA[<h2 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h2><p>保证应用程序与目标数据之间交互规范和协议的数据库或文件系统—-对数据库交互操作的抽象<br>特性是封装了建立连接，向外暴露获取连接的接口</p><h3 id="不提供连接池"><a href="#不提供连接池" class="headerlink" title="不提供连接池"></a>不提供连接池</h3><p>Spring中提供的数据源，例如DriverManagerDataSource<br><strong>对每个连接请求建立新的连接，程序使用完毕后销毁</strong>，交互频繁时明显存在大量时空开销<br>建议仅在测试时使用</p><h3 id="提供连接池"><a href="#提供连接池" class="headerlink" title="提供连接池"></a>提供连接池</h3><p>创建和管理一组连接对象的技术，以Apaceh Jakarta Commons DBCP and C3P0为例</p><h4 id="Apache连接池技术"><a href="#Apache连接池技术" class="headerlink" title="Apache连接池技术"></a>Apache连接池技术</h4><h2 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h2><p>无论是自动配置还是手动配置，均需要在pom.xml添加相关依赖<br>eg:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--添加MySQL依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--添加JDBC依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org,springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>默认选用HikariCP<br><del>如不可用，如果Tomcat池化DataSource可用选用它</del><br><del>如果以上都不可用， Commons DBCP2可用选用它？</del></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在<code>application.propertites</code>文件中添加以下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br>spring.datasource.url=jdbc:mysql:<span class="hljs-comment">//localhost/test</span><br><span class="hljs-comment">//</span><br>spring.datasource.username=...<br><span class="hljs-comment">//</span><br>spring.datasource.paddword=...<br><span class="hljs-comment">//数据库驱动程序类名，该驱动被废弃，选用com.mysql.cj.jdbc.Drvier，该驱动自动加载</span><br><span class="hljs-comment">//所以无需再propertis指定驱动</span><br>spring.datasource.driver-class-name=com.mysql.jdbc.Driver<br><span class="hljs-comment">//配置数据源类型，默认情况下使用HikariCP，其他则需要在pom.xml文件中添加相应的依赖项</span><br>spring.datasource.type=....<br><span class="hljs-comment">//配置连接池大小</span><br>spring.datasource.hikari.maximum-pool-size=<br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>或者<code>application.yml</code>文件中添加如下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br><span class="hljs-attr">datasource:</span><br><span class="hljs-attr">url:</span><br><span class="hljs-attr">driverClassName:</span><br><span class="hljs-attr">username:</span><br><span class="hljs-string">password</span><br></code></pre></td></tr></table></figure><h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在IoC容器初始化时实例化该数据源</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> calss DataSourceConfig&#123;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">DriverManagerDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DriverManagerDataSource</span>();<br>dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>dataSource.setUrl...<br><span class="hljs-keyword">return</span> dataSource;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Configuration注解将该类标记为配置类，通过Bean注解将dataSource标记为Bean</p><h3 id="多数据源配置"><a href="#多数据源配置" class="headerlink" title="多数据源配置"></a>多数据源配置</h3><p>如果需要同时连接多个数据库，在SpringBoot中使用多数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSource</span> Config&#123;<br><span class="hljs-meta">@Bean(name=&quot;primaryDataSource&quot;)</span><br><span class="hljs-meta">@Primary</span><br><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)</span><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">primaryDataSource</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> DataSourceBuilder.create().build();<br>&#125;<br><span class="hljs-meta">@Bean(name=&quot;secondaryDataSource&quot;)</span><br><span class="hljs-meta">@ConfigurationProperties(prefix=&quot;spring.datasource.secondary&quot;)</span><br><span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">secondaryDataSource</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> DataSourceBuilder.create().build();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用@ConfigurationProperties注解来指定配置文件中的前缀，确保SpringBoot自动将属性绑定到DataSource对象上。<br>通过@Primary注解确保没有指定具体的数据源名称时，自动选择primary</p><h3 id="切换默认数据源"><a href="#切换默认数据源" class="headerlink" title="切换默认数据源"></a>切换默认数据源</h3><h4 id="保留数据源依赖"><a href="#保留数据源依赖" class="headerlink" title="保留数据源依赖"></a>保留数据源依赖</h4><p>  在引入spring-boot-starter-jdbc依赖时，包含了Tomcat-JDBC依赖，因此切换时，需要排除该依赖，再填上需要的数据源依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-comment">&lt;!--排除Tomcat-JDBC依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--添加依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span> com.zaxxer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span> HikariCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="spring-datasource-type"><a href="#spring-datasource-type" class="headerlink" title="spring.datasource.type"></a>spring.datasource.type</h4><p>  在核心配置(application.properties)指定数据源类型</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">spring.datasource.<span class="hljs-keyword">type</span> <span class="hljs-type">= </span>com.zaxxer.hikari.HikariDataSource<br># spring.datasource.<span class="hljs-keyword">type</span> <span class="hljs-type">= </span>org.apache.tomcat.jdbc.pool.DataSource<br># spring.datasource.<span class="hljs-keyword">type</span> <span class="hljs-type">= </span>org.apache.commons.dbcp.BasicDataSource<br># spring.datasource.<span class="hljs-keyword">type</span> <span class="hljs-type">= </span>org.apache.commons.dbcp2.BasicDataSource<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]<a href="https://cloud.tecent.com/developer/article/2258704">https://cloud.tecent.com/developer/article/2258704</a><br>[2]<a href="https://juejin.cn/post/6844903654223265800#heading-2">https://juejin.cn/post/6844903654223265800#heading-2</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>CodingExp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringTransaction配置</title>
    <link href="/2023/11/d3c46eed3e7c.html"/>
    <url>/2023/11/d3c46eed3e7c.html</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-声明式事务"><a href="#Spring-声明式事务" class="headerlink" title="Spring 声明式事务"></a>Spring 声明式事务</h2><h3 id="基于XML配置"><a href="#基于XML配置" class="headerlink" title="基于XML配置"></a>基于XML配置</h3><h3 id="基于-Transaction注解"><a href="#基于-Transaction注解" class="headerlink" title="基于@Transaction注解"></a>基于@Transaction注解</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置事务管理器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;transactionManger&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">class</span> = <span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--注入数据库连接池--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;dataSource&quot;</span>, <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用基于注解方式配置事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManger&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>接下来只需要在Service类或方法上面添加@Transactional注解即可</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>默认配置下Spring只会回滚<strong>运行时、未检查异常(继承RuntimeException)</strong> 或者Error。但是我们可以通过<strong>rollbackFor</strong> 来指定要处理的异常【待添加相关代码示例】</li><li><code>@Transactional</code> 注解只能应用到<strong>public</strong> 修饰的方法上，在其他(protected…)等方法使用，不会报错，但是<em>该方法不会展示已配置的事务设置</em>？【待理解最后一句】</li><li><code>@Transaction</code>注解虽然可以被应用到接口定义或接口方法、类定义和类的public方法，但是建议在<strong>具体的类或方法</strong> 使用<code>@Transactional</code>注解，而不是在类实现的<strong>接口</strong> 上—-</li><li>如果<code>@Transactional</code>注解被写在Service类上面，表示该类中所有方法均被事务管理，但是有些查询方法不需要事务管理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Transactional(propagation= Propagation.NOT_SUPPORTED, readOnly=true)</span><br><span class="hljs-comment">//NOT_SUPPORTED表示以非事务方式运行，如果当前存在事务则暂停当前事务</span><br><span class="hljs-comment">//readOnly表示是否为只读事务，设置为true可以忽略无需事务的方法</span><br></code></pre></td></tr></table></figure></li><li>如果需要手动回滚事务，两种方法可选<ul><li>service层处理事务，service中的方法中不做异常捕获，或在catch语句中增加<code>throw new RuntimeException()</code> 语句，以便AOP捕获异常再回滚，在service上层(eg:view层Controller)捕获该异常处理</li><li>在service层方法的catch语句中增加：<code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()</code> 语句，手动回滚，无需上层处理</li></ul></li><li>@Transactional注解可以在类上也可以在方法上。大多数情况下，方法上的事务，会首先执行？什么样的方法事务注解会优先于类级别呢？</li><li>Proppagation.REQUIERES_NEW的问题——Spring中在默认代理模式下，目标方法由外部调用时，才能被Spring的事务拦截器拦截，同一类中的方法调用不会被拦截。[<a href="https://blog.csdn.net/qq_34845394/article/details/102921479]">https://blog.csdn.net/qq_34845394/article/details/102921479]</a></li></ol><h2 id="Spring编程式事务"><a href="#Spring编程式事务" class="headerlink" title="Spring编程式事务"></a>Spring编程式事务</h2><p>使用编码的方使用spring中提供的事务相关类来控制事务</p><h3 id="PlatformTransactionManager控制事务"><a href="#PlatformTransactionManager控制事务" class="headerlink" title="PlatformTransactionManager控制事务"></a>PlatformTransactionManager控制事务</h3><p><strong>步骤1</strong>——定义事务管理器PlatformTransactionManager<br>    用于开启事务、提交事务，回滚事务等操作，在spring中使用PlatformTransactionManager接口表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span>&#123;<br><span class="hljs-comment">//获取一个事务（开启事务）</span><br>TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br><span class="hljs-comment">//提交事务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br><span class="hljs-comment">//回滚事务</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口实现类</strong> 有许多，以应对不同的环境：</p><ul><li><code>JpaTransactionManager</code>:使用Jpa来操作db</li><li><code>DataSourceTransactionManager</code>:采用指定数据源的方式，使用JdbcTemplate||MyBatis||ibatis操作db</li><li><code>HibernateTransactionManager</code>:使用hibernate操作db</li><li><code>JtaTransactionManager</code>:通常是分布式事务下，使用Java中的jta操作db</li></ul><p><strong>步骤2——</strong> 定义事务属性TransactionDefinition<br>    定义事务属性，例如事务隔离级别（spring5种）、事务传播方式、事务超时时间、是否只读事务等。<br><strong>步骤3——</strong> 开启事务，使用getTransaction方法<br>    该方法会返回一个<code>TransactionStatus</code>表示事务状态的一个对象，通过该对象种的一些方法可以用来控制事务的一些状态（例如提交还是回滚）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionStatus</span><br></code></pre></td></tr></table></figure><p><strong>保存连接</strong> 执行完getTransaction方法后，Spring会从datasource中开启连接。将datasource和其对应的connection 存放在名resource的threadlocal中，以便后期获取 </p><p><strong>步骤4——</strong> 执行业务操作<br>    在jdbc中，和事务管理使用的是同一个datasource,所以，jdbcTemplate会从threadlocal中找有无关联的连接，有则使用没有则重新创建。通过相同connection来使得jdbcTemplate参与到spring中事务<br><strong>步骤5——</strong> 提交or回滚</p><h4 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h4><p>from[<a href="https://blog.csdn.net/qq_32062699/article/details/109195228]">https://blog.csdn.net/qq_32062699/article/details/109195228]</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><span class="hljs-comment">//定义一个数据源</span><br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DtaSource</span>();<br>dataSource.set......;<span class="hljs-comment">//(url,DriverClassName)</span><br><span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(dataSource);<br><span class="hljs-comment">//定义事务管理其，指定一个数据</span><br><span class="hljs-type">PlatfromTransactionManager</span> <span class="hljs-variable">platformTransactionManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br><span class="hljs-comment">//定义事务属性</span><br><span class="hljs-type">TransactionDefinition</span> <span class="hljs-variable">transactionDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultTransactionDefinition</span>();<br><span class="hljs-comment">//开启事务</span><br><span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">transactionStatus</span> <span class="hljs-operator">=</span> platformTransactionManager.getTransaction(transactionDefinition);<br><span class="hljs-comment">//执行业务操作</span><br><span class="hljs-keyword">try</span>&#123;<br>....<span class="hljs-comment">//执行sql语句</span><br>platformTransactionManager.commit(transactionStatus);<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>platformTransactionManager.rollback(transactionStatus);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TransactionTemplate控制事务"><a href="#TransactionTemplate控制事务" class="headerlink" title="TransactionTemplate控制事务"></a>TransactionTemplate控制事务</h3><p> 对platformTransactionManager的提交和回滚事务代码进行优化,同样需要定义事务管理器，定义事务属性。<br> 但是在开启事务时，选用TransactionTemplate<br> 提交时，两种方法</p><ul><li><code>executeWithoutResult</code>，无返回值场景<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">transactionTemplate.executeWithoutResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;TransactionStatus&gt;()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(TransactionStatus transactionStatus)</span>&#123;<br>....<span class="hljs-comment">//执行业务操作</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><code>execute</code> ，返回值场景，这里以Integer为例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallback</span>&lt;Integer&gt;()&#123;<br><span class="hljs-meta">@Nullable</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span>&#123;<br><span class="hljs-keyword">return</span> jdbcTemplate......;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p> 回滚时，两种方法</p><ul><li>在提交方法内部执行transactionStatus.setRollbackOnly(), 将事务状态标注为回滚状态，spring会自动让事务回滚</li><li>提交方法内部抛出任意异常即可</li></ul><h4 id="案例代码-1"><a href="#案例代码-1" class="headerlink" title="案例代码"></a>案例代码</h4><p>from[<a href="https://blog.csdn.net/qq_32062699/article/details/109195228]">https://blog.csdn.net/qq_32062699/article/details/109195228]</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>DataSource dataSource ....<br>dataSource.set.....<br>PlatformTransactionManager ....<br>DefaultTransaction ....<br><span class="hljs-comment">//创建TransactionTemplate对象</span><br><span class="hljs-type">TransactionTemplate</span> <span class="hljs-variable">transactionTemplate</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionTemplate</span>(platformTransactionManager,transactionDefinition);<br><span class="hljs-comment">//提交事务</span><br>transactionTemplate.executeWithoutResult(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;TransactionStatus&gt;()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(TransactionStatus transactionStatus)</span>&#123;<br>....<span class="hljs-comment">//执行业务操作</span><br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>CodingExp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB八股</title>
    <link href="/2023/11/ddd3b9719304.html"/>
    <url>/2023/11/ddd3b9719304.html</url>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h2 id="A-原子性"><a href="#A-原子性" class="headerlink" title="A(原子性)"></a>A(原子性)</h2><h2 id="C-一致性"><a href="#C-一致性" class="headerlink" title="C(一致性)"></a>C(一致性)</h2><h2 id="I-隔离性"><a href="#I-隔离性" class="headerlink" title="I(隔离性)"></a>I(隔离性)</h2><h2 id="D-持久性"><a href="#D-持久性" class="headerlink" title="D(持久性)"></a>D(持久性)</h2>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Database</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Database</tag>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL八股</title>
    <link href="/2023/11/16d4e34312d0.html"/>
    <url>/2023/11/16d4e34312d0.html</url>
    
    <content type="html"><![CDATA[<h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>插图</p><h3 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h4><ol><li>设计金钱的选用数据类型，考虑到精度问题选用Decimal和Numric类型表示<ol><li>Decimal简介——column_name DECIMAL(P,D)，其中P代表有效数字精度1-65默认值为10，D代表小数点后的位数0-30默认值为0. 【D&lt;&#x3D;P】</li><li>Decimal具有UNSIGNED属性【不接受负值】</li><li>Deciaml具有ZEROFILL属性【使用0填充不满足列宽的部分】</li><li>对于每个部分使用<strong>4字节</strong> 存储<strong>9位数的每个倍数</strong> 【待调查】</li></ol></li><li></li></ol><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="三个日志"><a href="#三个日志" class="headerlink" title="三个日志"></a>三个日志</h3><h4 id="bin-log（二进制）"><a href="#bin-log（二进制）" class="headerlink" title="bin log（二进制）"></a>bin log（二进制）</h4><h4 id="redo-log（事务）"><a href="#redo-log（事务）" class="headerlink" title="redo log（事务）"></a>redo log（事务）</h4><h4 id="undo-log（回滚）"><a href="#undo-log（回滚）" class="headerlink" title="undo log（回滚）"></a>undo log（回滚）</h4><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p> 原因：bin log &amp; redo log 写入时机不一致，导致在主从恢复时，数据可能不一致。【】<br> 解决：redo log 的写入分为两步<strong>prepare</strong> &amp; <strong>commit</strong>, 事务执行过程中进行prepare,事务提交过程中commit。当写入bin log异常时，redo log没有进入commit且没有对应的bin log则回滚事务。</p><h2 id="索引（持久性）"><a href="#索引（持久性）" class="headerlink" title="索引（持久性）"></a>索引（持久性）</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>用于快速查询和检索数据的数据结构，常见的实现采用B树、B+树、Hash、红黑树</p><p>优点：加快数据检索速度，可以创建唯一性索引保证每一行数据的唯一性<br>缺点：创建和维护需要消耗时间（对数据增删改）、消耗空间</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>  二叉树，左节点小于根节点小于叶子节点</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>  只有<strong>叶子</strong>节点存放key&amp;data（检索效率稳定）<br>  且叶子节点有引用链指向相邻的叶子节点（范围查询高效）</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>  自平衡二叉树，通过插入（删除）节点时，进行颜色变化和旋转操作，保持平衡</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="根据存储方式"><a href="#根据存储方式" class="headerlink" title="根据存储方式"></a>根据存储方式</h4><p>  聚簇索引：索引结构和数据一起存放（<strong>索引-数据</strong>||以数据域的值为地址读取相应的的数据记录，例如主键）<br>  非聚簇索引：索引结构和数据分开存放（<strong>索引-索引-数据</strong>||叶子节点不一定存放数据的指针）<br>  覆盖索引：查询的字段正好时索引的字段<br>  联合索引：使用表种多个字段创建索引（<strong>遵循最左匹配原则</strong>，遇到范围查询停止）<br><a href="https://zhuanlan.zhihu.com/p/142139541">判断是不是聚簇索引</a>(核心在于判断是否要<strong>回表查询</strong>)</p><h4 id="根据应用维度"><a href="#根据应用维度" class="headerlink" title="根据应用维度"></a>根据应用维度</h4><p>  主键索引：数据表的主键列为索引（不可以有null，表中只有1个）<br>  唯一索引：加速查询+劣质唯一（可以有null）避免数据重复<br>  普通索引：仅加速查询，选择数据整齐、紧凑的列<br>  覆盖索引：一个索引覆盖了<strong>所有</strong>需要查询的字段值<br>  联合索引：多列值组成一个索引，专门用于搜索，效率大于索引合并？<br>  全文索引：目前只有CHAR\VARCHAR\TEXT列上可以创建全文索引，一般采用ElasticSearch代替</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="索引优化（建立）"><a href="#索引优化（建立）" class="headerlink" title="索引优化（建立）"></a>索引优化（建立）</h4><ol><li>创建单列还是多列索引—&gt;如果拆线呢语句中的where、order by、group涉及多个字段，一般需要创建多列索引，例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>&quot;h&quot; <span class="hljs-keyword">and</span> job<span class="hljs-operator">=</span>&quot;programmer&quot;;<br></code></pre></td></tr></table></figure></li><li>多列索引的顺序选择—-&gt;将选择性高的字段【能定位的数据更少】放在前面，<strong>但是</strong>，满足某个查询场景就可能导致另外一个查询场景慢。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;zh&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure></li><li>避免使用范围查询—-&gt;很多情况下，范围查询都可能导致无法使用索引</li><li>尽量避免查询不需要的数据—-&gt;减少【*】的使用<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> job <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%grammer&#x27;</span>; # 全表遍历<br>explain <span class="hljs-keyword">select</span> job <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> job <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%grammer&#x27;</span>; # 使用覆盖索引<br></code></pre></td></tr></table></figure></li><li>查询的数据类型要正确<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> create_Date <span class="hljs-operator">&gt;=</span> now(); # 可以使用create_date的索引<br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> create_Date <span class="hljs-operator">&gt;=</span>&quot;2023-11-23&quot;; # 不可以<br></code></pre></td></tr></table></figure></li></ol><h4 id="索引命中（失效）"><a href="#索引命中（失效）" class="headerlink" title="索引命中（失效）"></a>索引命中（失效）</h4><ol><li>对索引列进行操作（加减操作）</li><li>使用or + 没有索引的列</li><li>存在隐式类型转换，例如字符串查询，输入数字会转为浮点（）</li><li>like通配符，以【%】开头进行的模糊查询（建议使用覆盖索引或以将%放后面）</li><li>!&#x3D;, not in, is null, not null</li><li>查询联合索引不满足最左原则</li></ol><h4 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>  针对<strong>联合索引</strong>，根据索引进行优化，将确定值的索引列排在前面，按索引顺序进行查询（避免范围查询引起后面索引的无序）  <a href="https://cloud.tencent.com/developer/article/1774781">看不懂请看原篇</a><br>  举例<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 某表现有索引（a,b,c）<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">1</span>;#利用索引a,b,c<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b<span class="hljs-operator">=</span><span class="hljs-number">1</span>; # 只能用到索引中的a,b<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span>; # 只能用到索引中的a,b(mysql查询优化器)<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span>;         # 只能用到索引中的a<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> b<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">1</span>; # 不能使用索引<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t <span class="hljs-keyword">where</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c<span class="hljs-operator">=</span><span class="hljs-number">1</span>; # 只能用到索引中的a<br></code></pre></td></tr></table></figure></p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>  因为索引<strong>底层实现是B+树</strong><br>  插图</p><h5 id="为啥使用联合索引"><a href="#为啥使用联合索引" class="headerlink" title="为啥使用联合索引"></a>为啥使用联合索引</h5><ol><li>减少开销。建立一个联合索引(col1, col2, col3)，实际相当于建立(col1), (col1, col2), (col1, col2, col3)三个索引。每多一个索引会增加写操作的时空开销。</li><li>覆盖索引。对于联合索引(col1, col2, col3)，采用<code>select col1....</code>sql语句会之间通过遍历索引获取数据，无需<strong>回表</strong>，减少IO操作。</li><li>效率高。索引列越多，筛选的数据越少</li></ol><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p> 在非聚簇索引遍历过程中，对索引中包含的字段先左判断，过滤掉不符合条件的记录，减少回表次数（核心在于判断条件中某一部分不在应用程序而是交给数据引擎）</p><h5 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h5><ol><li>存储引擎读取索引记录（不是完整的行记录）</li><li>判断WHERE条件<strong>部分</strong>能否用<strong>索引中的列</strong>来检查，条件不满足则处理下一行</li><li>条件满足，使用索引中的主键定位并读取完成的行记录（回表）</li><li>存储引擎将记录交给Server层，Server层检测记录是否满足WHERE条件其余部分。</li></ol><h5 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h5><ul><li>对于InnoDB只适用于二级（辅助）索引</li><li>引用了<strong>子查询</strong>的条件以及<strong>存储函数</strong>的条件不能下推</li></ul><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><ul><li>通过skywalking压测时查询到某一具体接口</li><li>MySQL开启慢日志查询</li><li>SQL优化—通过EXPLAIN 命令查看是否使用索引</li></ul><h4 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h4><table><thead><tr><th align="center">动作</th><th align="center">使用聚簇索引</th><th align="center">使用非聚簇索引</th></tr></thead><tbody><tr><td align="center">列经常被分组排序</td><td align="center">应</td><td align="center">应</td></tr><tr><td align="center">返回某范围内的数据</td><td align="center">应</td><td align="center">不应</td></tr><tr><td align="center">一个或极少不同值</td><td align="center">不应</td><td align="center">不应</td></tr><tr><td align="center">小数目的不同值</td><td align="center">应</td><td align="center">不应</td></tr><tr><td align="center">大数目的不同值</td><td align="center">不应</td><td align="center">应</td></tr><tr><td align="center">频繁更新的列</td><td align="center">不应</td><td align="center">应</td></tr><tr><td align="center">外键列</td><td align="center">应</td><td align="center">应</td></tr><tr><td align="center">主键列</td><td align="center">应</td><td align="center">应</td></tr><tr><td align="center">频繁修改索引列</td><td align="center">不应</td><td align="center">应</td></tr></tbody></table><h5 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h5><p> <strong>todo</strong></p><h5 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h5><p> <strong>聚簇索引默认是主键</strong>，如果表中没有定义主键，InnoDB会选择<strong>唯一的非空索引</strong>代替，<br>                                     如果没有唯一非空索引，InnoDB会<strong>隐式定义一个主键</strong>。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>  每次使用辅助（非聚簇）索引检索都要经过两次B+树查找<br>  优点：<br>      1. 行数据和叶子节点存储在一起，同一页中会有多行数据，页是加载到内存中，再次访问会从内存中读取。<br>      2. 非聚簇索引，使用主键作为”指针“，减少当出现行移动或数据页分裂【行的位置随数据修改而变化】需要的维护。即InnoDB在移动行时，无序更新辅助索引的指针。<br>      3. 聚簇索引适合排序场合或进行范围查询<br>  缺点：<br>      1. 维护聚簇索引很麻烦，数据移动会造成空间碎片<br>      2. 如果主键存储稀疏（？），可能出现聚簇索引比全表扫描慢</p><h2 id="事务（隔离性）"><a href="#事务（隔离性）" class="headerlink" title="事务（隔离性）"></a>事务（隔离性）</h2><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><h3 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h3><h2 id="锁（原子性）"><a href="#锁（原子性）" class="headerlink" title="锁（原子性）"></a>锁（原子性）</h2><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><h4 id="update加锁"><a href="#update加锁" class="headerlink" title="update加锁"></a>update加锁</h4><h4 id="select-加锁"><a href="#select-加锁" class="headerlink" title="select 加锁"></a>select 加锁</h4>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Database</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Database</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java特性八股</title>
    <link href="/2023/11/1565c76f39fc.html"/>
    <url>/2023/11/1565c76f39fc.html</url>
    
    <content type="html"><![CDATA[<h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h2 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h2>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Java</tag>
      
      <tag>语言特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM八股</title>
    <link href="/2023/11/b06c928cec1b.html"/>
    <url>/2023/11/b06c928cec1b.html</url>
    
    <content type="html"><![CDATA[<h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="基础概念（定义、使用）"><a href="#基础概念（定义、使用）" class="headerlink" title="基础概念（定义、使用）"></a>基础概念（定义、使用）</h3><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h3 id="GarbageCollection"><a href="#GarbageCollection" class="headerlink" title="GarbageCollection"></a>GarbageCollection</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><h4 id="GC算法举例"><a href="#GC算法举例" class="headerlink" title="GC算法举例"></a>GC算法举例</h4><h5 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h5><h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis八股</title>
    <link href="/2023/11/3c28c9581e7e.html"/>
    <url>/2023/11/3c28c9581e7e.html</url>
    
    <content type="html"><![CDATA[<h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="AOF-AppendOnlyFile"><a href="#AOF-AppendOnlyFile" class="headerlink" title="AOF(AppendOnlyFile)"></a>AOF(AppendOnlyFile)</h4><h4 id="RDB-redisDatabase"><a href="#RDB-redisDatabase" class="headerlink" title="RDB(redisDatabase)"></a>RDB(redisDatabase)</h4><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="三问"><a href="#三问" class="headerlink" title="三问"></a>三问</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h4 id="缓存-amp-DB一致性"><a href="#缓存-amp-DB一致性" class="headerlink" title="缓存&amp;DB一致性"></a>缓存&amp;DB一致性</h4><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="List实现"><a href="#List实现" class="headerlink" title="List实现"></a>List实现</h3><h3 id="Pub-x2F-Sub实现"><a href="#Pub-x2F-Sub实现" class="headerlink" title="Pub&#x2F;Sub实现"></a>Pub&#x2F;Sub实现</h3><h3 id="ZSet实现"><a href="#ZSet实现" class="headerlink" title="ZSet实现"></a>ZSet实现</h3><h3 id="Stream实现"><a href="#Stream实现" class="headerlink" title="Stream实现"></a>Stream实现</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h3 id="对比Kafka"><a href="#对比Kafka" class="headerlink" title="对比Kafka"></a>对比Kafka</h3><h3 id="对比RabbitMQ"><a href="#对比RabbitMQ" class="headerlink" title="对比RabbitMQ"></a>对比RabbitMQ</h3><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p> CAP理论，即C(consistency)一致性、A(Availabilty)可用性、P(Partition tolerance)分区容错性<br> P是必要因素，所以分为AP&amp;CP两种，核心在于一致性是否牺牲</p><h3 id="Rediss-实现-AP"><a href="#Rediss-实现-AP" class="headerlink" title="Rediss 实现-AP"></a>Rediss 实现-AP</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>AP模式下的分布式锁，目的在于保证系统的<strong>可用性</strong>，要求数据一致性不严苛。</p><ol><li>SETNEX: key不存在的情况下，设置value，否则不做操作。设置成功返回为1，失败为0</li><li>EXPIRE: 设置过期时间（避免死锁）</li><li>lua脚本确保上锁的原子操作（避免死锁）</li><li>释放锁通过删除del实现<ol><li>value字段添加当前线程id(锁标识)，避免误删</li></ol></li><li>可重入（记录加锁次数以及锁标识，Map结构）</li><li>自动续期（避免业务时间过长或锁持有时间太短）</li></ol><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h5><h5 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h5><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>Redis存储结构无法保证主从节点数据的一致性，无法保证主节点宕机时，所有数据自动同步到从节点。Redis分布式锁会在主节点宕机情况下，<strong>丢失锁信息</strong>，出现重复上锁</p><h3 id="zookeeper实现-CP"><a href="#zookeeper实现-CP" class="headerlink" title="zookeeper实现-CP"></a>zookeeper实现-CP</h3><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>zookeeper有一种节点类型为临时序号节点，按序号自增创建临时节点。<br>其创建可以分为读锁和写锁<br>读锁获取：<br>    1、根据资源ID创建临时序号节点：&#x2F;lock&#x2F;mylcokR0005 Read<br>    2、获取&#x2F;lock下所有子节点，判断比它小的节点是否<strong>全是</strong>读锁，如果是则获取成功<br>    3、如果不是（表明有写锁），阻塞等待，监听自己前一个节点<br>    4、当前面一个节点<strong>发生变更</strong>(删除)，重新执行第二步<br>写锁获取：<br>    1、根据资源ID创建临时序号节点：&#x2F;lock&#x2F;mylcokR0006 Write<br>    2、获取&#x2F;lock下所有子节点，<strong>判断最小的节点是否是自己</strong>，如果是则上锁<br>    3、如果不是，则阻塞等待，监听前一个节点<br>    4、当前一个节点发生变更(删除)，重新执行第二步</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><p>[1]<a href="https://blog.csdn.net/qq_41401800/article/details/106764515">https://blog.csdn.net/qq_41401800/article/details/106764515</a><br>[2]<a href="https://blog.csdn.net/qq_41973594/article/details/113576268">https://blog.csdn.net/qq_41973594/article/details/113576268</a></p><h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis八股</title>
    <link href="/2023/11/fa4eb5c3ed41.html"/>
    <url>/2023/11/fa4eb5c3ed41.html</url>
    
    <content type="html"><![CDATA[<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><h4 id="一二级缓存"><a href="#一二级缓存" class="headerlink" title="一二级缓存"></a>一二级缓存</h4><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><h2 id="MyBatis-plus"><a href="#MyBatis-plus" class="headerlink" title="MyBatis-plus"></a>MyBatis-plus</h2>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Java</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud八股</title>
    <link href="/2023/11/82e59fe8c9c1.html"/>
    <url>/2023/11/82e59fe8c9c1.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Java</tag>
      
      <tag>微服务</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring八股</title>
    <link href="/2023/11/ed9e2fefdaf0.html"/>
    <url>/2023/11/ed9e2fefdaf0.html</url>
    
    <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><h3 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h3 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h3><h4 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h4><h4 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h4><h5 id="注解原理"><a href="#注解原理" class="headerlink" title="注解原理"></a>注解原理</h5><h5 id="注解处理"><a href="#注解处理" class="headerlink" title="注解处理"></a>注解处理</h5><h4 id="注解使用-哪些注解"><a href="#注解使用-哪些注解" class="headerlink" title="注解使用(哪些注解)"></a>注解使用(哪些注解)</h4><h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><h3 id="怎么用-1"><a href="#怎么用-1" class="headerlink" title="怎么用"></a>怎么用</h3><h3 id="怎么实现-1"><a href="#怎么实现-1" class="headerlink" title="怎么实现"></a>怎么实现</h3><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h4 id="单例Bean线程安全"><a href="#单例Bean线程安全" class="headerlink" title="单例Bean线程安全"></a>单例Bean线程安全</h4><pre><code class="hljs">条件：判断Spring 单例Bean是否线程安全，需要根据bean对象中是否有可变的状态（变量）。为啥：多个线程对单例bean的状态存在进行修改（体现在单例成员的属性修改）结论：单例singleton的bean没有需要注入的状态（无可修改变量），例如Service类或Dao类。如果有bean中有可修改的变量，则需要改变作用域从singleton到prototype或者自定义并发处理逻辑【待处理https://cloud.tecent.com/developer/article/1743283】</code></pre><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><h4 id="缓存依赖"><a href="#缓存依赖" class="headerlink" title="缓存依赖"></a>缓存依赖</h4><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="AOP定义（逻辑"><a href="#AOP定义（逻辑" class="headerlink" title="AOP定义（逻辑"></a>AOP定义（逻辑</h3><h3 id="AOP实现"><a href="#AOP实现" class="headerlink" title="AOP实现"></a>AOP实现</h3><h3 id="AOP使用"><a href="#AOP使用" class="headerlink" title="AOP使用"></a>AOP使用</h3><h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h2><h3 id="IoC定义"><a href="#IoC定义" class="headerlink" title="IoC定义"></a>IoC定义</h3><h3 id="IoC实现"><a href="#IoC实现" class="headerlink" title="IoC实现"></a>IoC实现</h3><h3 id="IoC使用"><a href="#IoC使用" class="headerlink" title="IoC使用"></a>IoC使用</h3><h4 id="IoC执行流程"><a href="#IoC执行流程" class="headerlink" title="IoC执行流程"></a>IoC执行流程</h4><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><h4 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h4><h4 id="配置属性绑定"><a href="#配置属性绑定" class="headerlink" title="配置属性绑定"></a>配置属性绑定</h4><h4 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h4><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程八股</title>
    <link href="/2023/11/8d139f981dac.html"/>
    <url>/2023/11/8d139f981dac.html</url>
    
    <content type="html"><![CDATA[<h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal定义"><a href="#ThreadLocal定义" class="headerlink" title="ThreadLocal定义"></a>ThreadLocal定义</h3><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Java</tag>
      
      <tag>Thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合八股</title>
    <link href="/2023/11/05620d96e85d.html"/>
    <url>/2023/11/05620d96e85d.html</url>
    
    <content type="html"><![CDATA[<h2 id="ReadMe"><a href="#ReadMe" class="headerlink" title="ReadMe"></a>ReadMe</h2>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>CodingLanguage</category>
      
      <category>Java</category>
      
      <category>Language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
      <tag>Java</tag>
      
      <tag>Collections</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
